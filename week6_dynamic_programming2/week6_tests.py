import unittest
from random import randint
from knapsack import maximum_gold
from partition3 import partition3
from placing_parentheses import maximum_value
import time

def test_runtime(max_runtime: int, function: callable, *args):
    NANOSECONDS_PER_SECOND = int(10e9)
    start_time = time.perf_counter()
    _ = function(*args)
    end_time = time.perf_counter()

    elapsed = (end_time - start_time) / NANOSECONDS_PER_SECOND
    return elapsed <= max_runtime

class TestKnapsack(unittest.TestCase):
    def test_backpack_each_bar_less_than_capacity(self):
        self.assertEqual(maximum_gold(10,[1,4,8]), 9)
        
        """The following generated with ChatGPT"""
        # 1. Multiple small bars that can perfectly fill capacity:
        self.assertEqual(maximum_gold(10, [2, 2, 2, 2, 2]), 10)

        # 2. Combination where a mix of small bars sums to max:
        self.assertEqual(maximum_gold(10, [3, 5, 3, 3]), 9)

        # 3. Exact fits with identical weights:
        self.assertEqual(maximum_gold(15, [5, 5, 5, 5]), 15)

        # 4. Can’t use all bars; best subset is chosen:
        self.assertEqual(maximum_gold(15, [6, 6, 6, 2, 1]), 15)

        # 5. Larger capacity with some big bars:
        #    Best subset is 10 + 10 = 20 (or 4+4+4+4+4 = 20)
        self.assertEqual(maximum_gold(20, [4, 4, 4, 4, 4, 10, 10]), 20)

    def test_backpack_one_bar_greater_than_capacity(self):
        """The following generated with ChatGPT"""
        # 1. Multiple small bars that can perfectly fill capacity:
        self.assertEqual(maximum_gold(10, [2, 2, 2, 2, 2, 50]), 10)

        # 2. Combination where a mix of small bars sums to max:
        self.assertEqual(maximum_gold(10, [3, 5, 3, 3, 50]), 9)

        # 3. Exact fits with identical weights:
        self.assertEqual(maximum_gold(15, [5, 5, 5, 5, 50]), 15)

        # 4. Can’t use all bars; best subset is chosen:
        self.assertEqual(maximum_gold(15, [6, 6, 6, 2, 1, 50]), 15)

        # 5. Larger capacity with some big bars:
        #    Best subset is 10 + 10 = 20 (or 4+4+4+4+4 = 20)
        self.assertEqual(maximum_gold(20, [4, 4, 4, 4, 4, 10, 10, 50]), 20)

    def test_backpack_each_bar_greater_than_capacity(self):
        # Single bar that’s bigger than capacity:
        self.assertEqual(maximum_gold(5, [6]), 0)

        # All bars are larger than capacity:
        self.assertEqual(maximum_gold(5, [6, 8, 10]), 0)

        # Another scenario:
        self.assertEqual(maximum_gold(1, [2, 3, 4]), 0)

    def test_max_input_does_not_exceed_runtime(self):
        """Function call with maximums of range should not exceed allowed runtime"""
        
        W = [10000]
        weights = [[10000 for _ in range(300)]]
        for _ in range(100):
            W.append(randint(1,10000))
            weights.append([randint(9,100000) for _ in range(randint(1,300))])

        for capacity, w in zip(W, weights):  
            self.assertTrue(test_runtime(1,maximum_gold, capacity, w))
        
class TestPartition3(unittest.TestCase):
    def test_provided_samples(self):
        self.assertEqual(partition3([3,3,3,3]), 0)
        self.assertEqual(partition3([30]), 0)
        self.assertEqual(partition3([1,2,3,4,5,5,7,7,8,10,12,19,25]), 1)

    """These were generated by ChatGPT"""
    def test_empty_list(self):
        # sum is 0, but we have no elements, so we can't form 3 nonempty subsets
        self.assertEqual(partition3([]), 0)

    def test_sum_not_divisible_by_3(self):
        # sum([3,3,3,4]) = 13, not divisible by 3 => immediate False
        self.assertEqual(partition3([3, 3, 3, 4]), 0)

    def test_all_zeros(self):
        # sum([0,0,0])=0 => target=0 => can partition into 3 subsets each summing to 0
        # (all subsets are effectively "empty" or all zero-values, so it's True)
        self.assertEqual(partition3([0, 0, 0]), 1)

    def test_six_threes(self):
        # sum([3,3,3,3,3,3])=18 => target=6
        # possible partition: [3,3], [3,3], [3,3]
        self.assertEqual(partition3([3, 3, 3, 3, 3, 3]), 1)

    def test_1_to_6(self):
        # sum([1,2,3,4,5,6])=21 => target=7
        # example partition: [1,6], [2,5], [3,4]
        self.assertEqual(partition3([1,2,3,4,5,6]), 1)

    def test_small_false_case(self):
        # sum([2,2,3])=7, not divisible by 3 => immediate False
        self.assertEqual(partition3([2,2,3]), False)

class TestPlacingParenthesis(unittest.TestCase):
        """These tests were generated with ChatGPT"""

        def test_example_1(self):
            """
            Expression: '8-5*3'
            Two ways to parenthesize:
            - ((8 - 5) * 3) = 9
            - (8 - (5 * 3)) = -7
            Expected maximum: 9
            """
            expr = "8-5*3"
            self.assertEqual(maximum_value(expr), 9, "Max value should be 9")

        def test_example_2(self):
            """
            Expression: '3+2*4'
            Two ways to parenthesize:
            - (3 + (2 * 4)) = 11
            - ((3 + 2) * 4) = 20
            Expected maximum: 20
            """
            expr = "3+2*4"
            self.assertEqual(maximum_value(expr), 20, "Max value should be 20")

        def test_example_3(self):
            """
            Expression: '5-8+7*4-8+9'
            The correct parenthesization yields the maximum value. 
            (Exact solution can be tested, but known result is 41 if done carefully.)
            """
            expr = "5-8+7*4-8+9"
            result = maximum_value(expr)
            expected = 200  # Commonly cited correct maximum for this arrangement
            self.assertEqual(result, expected, f"Max value should be {expected}, got {result}")

        def test_single_digit(self):
            """Expression: '7' (only one digit, no operators) -> max value is 7."""
            expr = "7"
            self.assertEqual(maximum_value(expr), 7, "Max value should be 7")

        def test_all_addition(self):
            """Expression: '1+2+3+4' -> straightforward: 1+2+3+4=10 is the only outcome anyway."""
            expr = "1+2+3+4"
            self.assertEqual(maximum_value(expr), 10, "Max value should be 10")


if __name__ == "__main__":
    unittest.main()